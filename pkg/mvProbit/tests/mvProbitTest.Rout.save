
R version 2.13.1 (2011-07-08)
Copyright (C) 2011 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: i686-pc-linux-gnu (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library( "mvProbit" )
Loading required package: mvtnorm
Loading required package: maxLik
Loading required package: miscTools
Loading required package: bayesm
> library( "miscTools" )
> 
> ## generate a simulated data set
> set.seed( 123 )
> # number of observations
> nObs <- 10
> 
> # generate explanatory variables
> xMat <- cbind( 
+    const = rep( 1, nObs ),
+    x1 = as.numeric( rnorm( nObs ) > 0 ),
+    x2 = as.numeric( rnorm( nObs ) > 0 ),
+    x3 = rnorm( nObs ),
+    x4 = rnorm( nObs ) )
> 
> # coefficients
> beta <- cbind( c(  0.8,  1.2, -1.0,  1.4, -0.8 ),
+                c( -0.6,  1.0,  0.6, -1.2, -1.6 ),
+                c(  0.5, -0.6, -0.7,  1.1,  1.2 ) )
> 
> # covariance matrix of error terms
> sigma <- symMatrix( c( 1, 0.2, 0.4, 1, -0.1, 1 ) )
> 
> # generate dependent variables
> yMatLin <- xMat %*% beta 
> yMat <- ( yMatLin + rmvnorm( nObs, sigma = sigma ) ) > 0
> colnames( yMat ) <- paste( "y", 1:3, sep = "" )
> # (yMatLin > 0 )== yMat
> 
> # unconditional expectations of dependent variables
> yExp <- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
+    sigma = sigma, data = as.data.frame( xMat ) )
> print( yExp )
           V1         V2         V3
1  0.02086892 0.72542879 0.19411024
2  0.39392340 0.76842941 0.21363900
3  0.12455645 0.78785603 0.19642672
4  0.23485392 0.68069956 0.29183903
5  0.67999333 0.43467562 0.57861599
6  0.02791996 0.97271018 0.03370023
7  0.95816411 0.18630028 0.78414444
8  0.85639266 0.24667543 0.72388317
9  0.06073636 0.96822363 0.03444764
10 0.99787991 0.06734972 0.92257845
> yExp2 <- pnorm( yMatLin )
> all.equal( yExp, as.data.frame( yExp2 ) )
[1] TRUE
> 
> # conditional expectations of dependent variables
> # (assuming that all other dependent variables are one)
> yExpCond <- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
+    sigma = sigma, data = as.data.frame( xMat ), cond = TRUE )
> print( yExpCond )
           V1         V2        V3
1  0.07187274 0.83441226 0.5236193
2  0.66023348 0.77856855 0.3142187
3  0.29709617 0.83846471 0.3994699
4  0.44823829 0.72724816 0.4608874
5  0.84677186 0.44247741 0.6176247
6  0.13901197 0.98492618 0.1616680
7  0.99080074 0.17880919 0.7487862
8  0.95048885 0.24377749 0.7104822
9  0.24434181 0.97834900 0.1330594
10 0.99980223 0.06515097 0.8917154
> yExpCond2 <- matrix( NA, nrow = nObs, ncol = ncol( yMat ) )
> for( i in 1:nObs ) {
+    for( k in 1:ncol( yMat ) ) {
+       set.seed( 123 )
+       numerator <- pmvnorm( upper = yMatLin[ i, ], sigma = sigma )
+       set.seed( 123 )
+       denominator <- pmvnorm( upper = yMatLin[ i, -k ], sigma = sigma[ -k, -k ] )
+       yExpCond2[ i, k ] <- numerator / denominator
+    }
+ }
> all.equal( yExpCond, as.data.frame( yExpCond2 ) )
[1] TRUE
> # now with explicitly specifying the algorithm
> yExpCond3 <- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
+    sigma = sigma, data = as.data.frame( xMat ), cond = TRUE,
+    algorithm = GenzBretz )
> all.equal( yExpCond, yExpCond3 )
[1] TRUE
> identical( yExpCond, yExpCond3 )
[1] TRUE
> # now with integrals obtained by the Miwa algorithm
> yExpCond4 <- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
+    sigma = sigma, data = as.data.frame( xMat ), cond = TRUE,
+    algorithm = Miwa )
> all.equal( yExpCond, yExpCond4 )
[1] "Component 1: Mean relative difference: 4.435478e-05"
[2] "Component 2: Mean relative difference: 0.0001002261"
[3] "Component 3: Mean relative difference: 5.938566e-05"
> # now with integrals obtained by the Miwa algorithm, less precise
> yExpCond5 <- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
+    sigma = sigma, data = as.data.frame( xMat ), cond = TRUE,
+    algorithm = Miwa( steps = 32 ) )
> all.equal( yExpCond4, yExpCond5 )
[1] "Component 1: Mean relative difference: 1.014946e-05"
[2] "Component 2: Mean relative difference: 1.070674e-05"
[3] "Component 3: Mean relative difference: 9.286508e-06"
> # now with integrals obtained by the TVPACK algorithm
> yExpCond6 <- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
+    sigma = sigma, data = as.data.frame( xMat ), cond = TRUE,
+    algorithm = TVPACK )
> all.equal( yExpCond, yExpCond6 )
[1] "Component 1: Mean relative difference: 4.435948e-05"
[2] "Component 2: Mean relative difference: 0.0001002157"
[3] "Component 3: Mean relative difference: 5.938604e-05"
> # now with integrals obtained by the TVPACK algorithm, less precise
> yExpCond7 <- mvProbitExp( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
+    sigma = sigma, data = as.data.frame( xMat ), cond = TRUE,
+    algorithm = TVPACK( abseps = 0.5 ) )
> all.equal( yExpCond6, yExpCond7 )
[1] "Component 1: Mean relative difference: 0.03017515"
[2] "Component 2: Mean relative difference: 0.04273065"
[3] "Component 3: Mean relative difference: 0.0424229" 
> 
> 
> # conditional expectations of dependent variables
> # (assuming that all other dependent variables are as observed)
> yExpCondObs <- mvProbitExp( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ), 
+    cond = TRUE )
> print( yExpCondObs )
           y1         y2         y3
1  0.01446330 0.73515489 0.17239140
2  0.36422466 0.74444655 0.11898201
3  0.10197280 0.78808436 0.15158540
4  0.19744044 0.81305670 0.46088740
5  0.46887344 0.54232735 0.70688505
6  0.02469662 0.97269183 0.02935400
7  0.97137607 0.17880919 0.80927845
8  0.88954588 0.24377749 0.78280394
9  0.05566761 0.96764681 0.02721613
10 0.99859830 0.06515097 0.92560102
> yExpCondObs2 <- matrix( NA, nrow = nObs, ncol = ncol( yMat ) )
> for( i in 1:nObs ){
+    for( k in 1:ncol( yMat ) ) {
+       ySign <- 2 * yMat[ i, ] - 1
+       ySign[ k ] <- 1
+       yLinTmp <- yMatLin[ i, ] * ySign
+       sigmaTmp <- diag( ySign ) %*% sigma %*% diag( ySign )
+       set.seed( 123 )
+       numerator <- pmvnorm( upper = yLinTmp, sigma = sigmaTmp )
+       set.seed( 123 )
+       denominator <- pmvnorm( upper = yLinTmp[ -k ], sigma = sigmaTmp[ -k, -k ] )
+       yExpCondObs2[ i, k ] <- numerator / denominator
+    }
+ }
> all.equal( yExpCondObs, as.data.frame( yExpCondObs2 ) )
[1] "Names: 3 string mismatches"
> # now with explicitly specifying the algorithm
> yExpCondObs3 <- mvProbitExp( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    cond = TRUE, algorithm = GenzBretz )
> all.equal( yExpCondObs, yExpCondObs3 )
[1] TRUE
> identical( yExpCondObs, yExpCondObs3 )
[1] TRUE
> # now with integrals obtained by the Miwa algorithm
> yExpCondObs4 <- mvProbitExp( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    cond = TRUE, algorithm = Miwa )
> all.equal( yExpCondObs, yExpCondObs4 )
[1] "Component 1: Mean relative difference: 9.258897e-05"
[2] "Component 2: Mean relative difference: 5.029085e-05"
[3] "Component 3: Mean relative difference: 0.0001009532"
> # now with integrals obtained by the Miwa algorithm, less precise
> yExpCondObs5 <- mvProbitExp( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    cond = TRUE, algorithm = Miwa( steps = 32 ) )
> all.equal( yExpCondObs4, yExpCondObs5 )
[1] "Component 1: Mean relative difference: 4.471818e-06"
[2] "Component 2: Mean relative difference: 3.954285e-06"
[3] "Component 3: Mean relative difference: 4.758699e-06"
> # now with integrals obtained by the TVPACK algorithm
> yExpCondObs6 <- mvProbitExp( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    cond = TRUE, algorithm = TVPACK )
> all.equal( yExpCondObs, yExpCondObs6 )
[1] "Component 1: Mean relative difference: 9.258463e-05"
[2] "Component 2: Mean relative difference: 5.028616e-05"
[3] "Component 3: Mean relative difference: 0.0001009503"
> # now with integrals obtained by the TVPACK algorithm, less precise
> yExpCondObs7 <- mvProbitExp( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    cond = TRUE, algorithm = TVPACK( abseps = 0.5 ) )
> all.equal( yExpCondObs6, yExpCondObs7 )
[1] "Component 1: Mean relative difference: 0.05130138"
[2] "Component 2: Mean relative difference: 0.04744355"
[3] "Component 3: Mean relative difference: 0.02586555"
> 
> 
> # unconditional expectations of dependent variables by simulation
> nSim <- 10000
> ySim <- array( NA, c( nObs, ncol( yMat ), nSim ) )
> for( s in 1:nSim ) {
+    ySim[ , , s ] <- ( yMatLin + rmvnorm( nObs, sigma = sigma ) ) > 0
+ }
> yExpSim <- matrix( NA, nrow = nObs, ncol = ncol( yMat ) )
> for( i in 1:nObs ) {
+    yExpSim[ i, ] <- rowSums( ySim[ i, , ] ) / nSim
+ }
> print( yExpSim )
        [,1]   [,2]   [,3]
 [1,] 0.0192 0.7292 0.1974
 [2,] 0.4004 0.7599 0.2151
 [3,] 0.1185 0.7867 0.1978
 [4,] 0.2374 0.6843 0.2992
 [5,] 0.6817 0.4368 0.5779
 [6,] 0.0275 0.9709 0.0356
 [7,] 0.9580 0.1843 0.7872
 [8,] 0.8551 0.2551 0.7156
 [9,] 0.0624 0.9697 0.0332
[10,] 0.9984 0.0636 0.9231
> print( yExpSim - as.matrix( yExp ) )
                 V1           V2            V3
 [1,] -0.0016689243  0.003771207  0.0032897559
 [2,]  0.0064765951 -0.008529406  0.0014610027
 [3,] -0.0060564475 -0.001156035  0.0013732843
 [4,]  0.0025460841  0.003600442  0.0073609724
 [5,]  0.0017066657  0.002124382 -0.0007159879
 [6,] -0.0004199629 -0.001810177  0.0018997717
 [7,] -0.0001641098 -0.002000281  0.0030555602
 [8,] -0.0012926616  0.008424570 -0.0082831712
 [9,]  0.0016636425  0.001476372 -0.0012476431
[10,]  0.0005200914 -0.003749723  0.0005215455
> 
> # for testing state of random number generator
> rnorm( 4 )
[1] -0.07304505  0.71128820  0.08262612 -1.11816720
> 
> # calculating log likelihood value(s)
> logLikVal <- mvProbitLogLik( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ) )
> print( logLikVal )
 [1] -0.53540368 -0.94155840 -0.55161623 -2.32656485 -2.25902218 -0.08645378
 [7] -0.46570791 -0.70386950 -0.12392314 -0.14927833
> # now with explicitly specifying the algorithm
> logLikVal3 <- mvProbitLogLik( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    algorithm = GenzBretz )
> all.equal( logLikVal, logLikVal3 )
[1] TRUE
> identical( logLikVal, logLikVal3 )
[1] TRUE
> # now with integrals obtained by the Miwa algorithm
> logLikVal4 <- mvProbitLogLik( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    algorithm = Miwa )
> all.equal( logLikVal, logLikVal4 )
[1] "Mean relative difference: 8.840686e-05"
> # now with integrals obtained by the Miwa algorithm, less precise
> logLikVal5 <- mvProbitLogLik( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    algorithm = Miwa( steps = 32 ) )
> all.equal( logLikVal4, logLikVal5 )
[1] "Mean relative difference: 4.53253e-06"
> # now with integrals obtained by the TVPACK algorithm
> logLikVal6 <- mvProbitLogLik( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    algorithm = TVPACK )
> all.equal( logLikVal, logLikVal6 )
[1] "Mean relative difference: 8.840067e-05"
> # now with integrals obtained by the TVPACK algorithm, less precise
> logLikVal7 <- mvProbitLogLik( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    algorithm = TVPACK( abseps = 0.5 ) )
> all.equal( logLikVal6, logLikVal7 )
[1] "Mean relative difference: 0.05527167"
> 
> # calculating log likelihood value(s) with one-sided gradients
> logLikValGrad <- mvProbitLogLik( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    oneSidedGrad = TRUE )
> print( logLikValGrad )
 [1] -0.53540368 -0.94155840 -0.55161623 -2.32656485 -2.25902218 -0.08645378
 [7] -0.46570791 -0.70386950 -0.12392314 -0.14927833
attr(,"gradient")
              [,1]        [,2]        [,3]         [,4]         [,5]
 [1,] -0.039483841  0.00000000 -0.03948384  0.042161678 -0.016838434
 [2,] -0.620181812  0.00000000 -0.62018181  0.135183996  0.182997851
 [3,] -0.208837065 -0.20883706 -0.20883706  0.214267423 -0.186935400
 [4,]  1.493926467  1.49392647  1.49392647 -1.088910460  1.311866906
 [5,]  0.917269941  0.91726994  0.00000000 -0.573330124  0.753611686
 [6,] -0.060924129 -0.06092413 -0.06092413  0.102760036 -0.041954794
 [7,]  0.071223816  0.07122382  0.07122382  0.059670401  0.039452148
 [8,]  0.224807263  0.00000000  0.00000000  0.034479413 -0.013918213
 [9,] -0.121700445  0.00000000 -0.12170044  0.138511513  0.037235750
[10,]  0.004787314  0.00000000  0.00000000  0.006002404 -0.001821438
             [,6]       [,7]        [,8]        [,9]       [,10]       [,11]
 [1,]  0.44704993  0.0000000  0.44704993 -0.47737105  0.19065086 -0.31393241
 [2,]  0.43840786  0.0000000  0.43840786 -0.09556198 -0.12936175 -0.24068300
 [3,]  0.37076298  0.3707630  0.37076298 -0.38040492  0.33187948 -0.28829263
 [4,]  0.33970605  0.3397061  0.33970605 -0.24760903  0.29830728 -0.79100711
 [5,] -0.88642408 -0.8864241  0.00000000  0.55404951 -0.72826921 -1.24501533
 [6,]  0.06467570  0.0646757  0.06467570 -0.10908836  0.04453830 -0.07038947
 [7,] -0.31973919 -0.3197392 -0.31973919 -0.26787333 -0.17710913  0.34377267
 [8,] -0.41846140  0.0000000  0.00000000 -0.06418070  0.02590765  0.39132057
 [9,]  0.07517436  0.0000000  0.07517436 -0.08555889 -0.02300058 -0.06658594
[10,] -0.13608740  0.0000000  0.00000000 -0.17062845  0.05177725  0.15270486
            [,12]       [,13]      [,14]       [,15]         [,16]        [,17]
 [1,]  0.00000000 -0.31393241 0.33522403 -0.13388089 -0.0089522200  0.031648334
 [2,]  0.00000000 -0.24068300 0.05246281  0.07101862 -0.2109161681  0.242606606
 [3,] -0.28829263 -0.28829263 0.29578911 -0.25805811 -0.0489604016  0.118484255
 [4,] -0.79100711 -0.79100711 0.57655770 -0.69460979  0.5931737070 -0.947273870
 [5,] -1.24501533  0.00000000 0.77818304 -1.02288098 -0.6958962371 -0.901556093
 [6,] -0.07038947 -0.07038947 0.11872513 -0.04847301 -0.0020805973  0.015112572
 [7,]  0.34377267  0.34377267 0.28800831  0.19042180 -0.0121688745  0.055215327
 [8,]  0.00000000  0.00000000 0.06001809 -0.02422734 -0.0620710172  0.159552938
 [9,]  0.00000000 -0.06658594 0.07578375  0.02037278 -0.0038911046  0.024566263
[10,]  0.00000000  0.00000000 0.19146359 -0.05809983 -0.0003026088  0.003157443
             [,18]
 [1,] -0.161540001
 [2,] -0.132532626
 [3,] -0.129196504
 [4,] -0.319508443
 [5,]  1.016442887
 [6,] -0.006549753
 [7,] -0.129101410
 [8,] -0.192174063
 [9,] -0.007700663
[10,] -0.026654477
> 
> # calculating log likelihood value(s) with two-sided gradients
> llTmp <- function( coef ) {
+    betaTmp <- coef[ 1:15 ]
+    sigmaTmp <- diag( 3 )
+    sigmaTmp[ upper.tri( sigmaTmp ) ] <- coef[ -(1:15) ]
+    sigmaTmp[ lower.tri( sigmaTmp ) ] <- t( sigmaTmp )[ lower.tri( sigmaTmp ) ]
+    result <- mvProbitLogLik( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+       coef = betaTmp, sigma = sigmaTmp, 
+       data = as.data.frame( cbind( xMat, yMat ) ) )
+    return( result )
+ }
> allCoef <- c( c( beta ), sigma[ upper.tri( sigma ) ] )
> logLikValGrad2 <- numericGradient( llTmp, allCoef )
> print( logLikValGrad2 )
              [,1]        [,2]        [,3]         [,4]         [,5]
 [1,] -0.039483794  0.00000000 -0.03948379  0.042161731 -0.016838426
 [2,] -0.620181508  0.00000000 -0.62018151  0.135184012  0.182997877
 [3,] -0.208836904 -0.20883690 -0.20883690  0.214267592 -0.186935271
 [4,]  1.493926913  1.49392691  1.49392691 -1.088910224  1.311867250
 [5,]  0.917270326  0.91727033  0.00000000 -0.573329973  0.753611947
 [6,] -0.060924066 -0.06092407 -0.06092407  0.102760215 -0.041954764
 [7,]  0.071223890  0.07122389  0.07122389  0.059670453  0.039452170
 [8,]  0.224807433  0.00000000  0.00000000  0.034479417 -0.013918213
 [9,] -0.121700338  0.00000000 -0.12170034  0.138511650  0.037235760
[10,]  0.004787322  0.00000000  0.00000000  0.006002416 -0.001821437
             [,6]        [,7]        [,8]        [,9]       [,10]       [,11]
 [1,]  0.44705018  0.00000000  0.44705018 -0.47737078  0.19065091 -0.31393221
 [2,]  0.43840810  0.00000000  0.43840810 -0.09556197 -0.12936173 -0.24068282
 [3,]  0.37076320  0.37076320  0.37076320 -0.38040469  0.33187965 -0.28829243
 [4,]  0.33970627  0.33970627  0.33970627 -0.24760892  0.29830745 -0.79100675
 [5,] -0.88642374 -0.88642374  0.00000000  0.55404964 -0.72826897 -1.24501491
 [6,]  0.06467576  0.06467576  0.06467576 -0.10908818  0.04453834 -0.07038940
 [7,] -0.31973900 -0.31973900 -0.31973900 -0.26787319 -0.17710907  0.34377288
 [8,] -0.41846116  0.00000000  0.00000000 -0.06418069  0.02590765  0.39132081
 [9,]  0.07517443  0.00000000  0.07517443 -0.08555880 -0.02300057 -0.06658587
[10,] -0.13608729  0.00000000  0.00000000 -0.17062827  0.05177727  0.15270498
           [,12]       [,13]      [,14]       [,15]         [,16]        [,17]
 [1,]  0.0000000 -0.31393221 0.33522426 -0.13388086 -0.0089522338  0.031648323
 [2,]  0.0000000 -0.24068282 0.05246282  0.07101864 -0.2109161814  0.242606594
 [3,] -0.2882924 -0.28829243 0.29578932 -0.25805795 -0.0489604439  0.118484204
 [4,] -0.7910068 -0.79100675 0.57655789 -0.69460952  0.5931740810 -0.947273090
 [5,] -1.2450149  0.00000000 0.77818321 -1.02288070 -0.6958959089 -0.901555435
 [6,] -0.0703894 -0.07038940 0.11872533 -0.04847297 -0.0020805997  0.015112555
 [7,]  0.3437729  0.34377288 0.28800846  0.19042187 -0.0121688919  0.055215307
 [8,]  0.0000000  0.00000000 0.06001809 -0.02422734 -0.0620710620  0.159552892
 [9,]  0.0000000 -0.06658587 0.07578384  0.02037279 -0.0038911139  0.024566240
[10,]  0.0000000  0.00000000 0.19146378 -0.05809982 -0.0003026087  0.003157441
             [,18]
 [1,] -0.161540032
 [2,] -0.132532661
 [3,] -0.129196543
 [4,] -0.319508409
 [5,]  1.016443490
 [6,] -0.006549763
 [7,] -0.129101448
 [8,] -0.192174094
 [9,] -0.007700674
[10,] -0.026654501
> attr( logLikValGrad, "gradient" ) / logLikValGrad2 - 1
               [,1]          [,2]          [,3]          [,4]          [,5]
 [1,]  1.169727e-06           NaN  1.169727e-06 -1.248160e-06  5.010976e-07
 [2,]  4.905034e-07           NaN  4.905034e-07 -1.125137e-07 -1.462114e-07
 [3,]  7.713836e-07  7.713836e-07  7.713836e-07 -7.906937e-07  6.907147e-07
 [4,] -2.984521e-07 -2.984521e-07 -2.984521e-07  2.173729e-07 -2.620121e-07
 [5,] -4.202354e-07 -4.202354e-07           NaN  2.625822e-07 -3.453187e-07
 [6,]  1.037576e-06  1.037576e-06  1.037576e-06 -1.742823e-06  7.131612e-07
 [7,] -1.035809e-06 -1.035809e-06 -1.035809e-06 -8.716868e-07 -5.740761e-07
 [8,] -7.585615e-07           NaN           NaN -1.159185e-07  6.381412e-08
 [9,]  8.733745e-07           NaN  8.733745e-07 -9.937063e-07 -2.716987e-07
[10,] -1.623363e-06           NaN           NaN -1.955981e-06  5.638164e-07
               [,6]          [,7]          [,8]          [,9]         [,10]
 [1,] -5.396519e-07           NaN -5.396519e-07  5.758443e-07 -2.294392e-07
 [2,] -5.538351e-07           NaN -5.538351e-07  1.254726e-07  1.647804e-07
 [3,] -5.893031e-07 -5.893031e-07 -5.893031e-07  6.047197e-07 -5.272126e-07
 [4,] -6.248770e-07 -6.248770e-07 -6.248770e-07  4.573452e-07 -5.523063e-07
 [5,]  3.897700e-07  3.897700e-07           NaN -2.436661e-07  3.201384e-07
 [6,] -9.979873e-07 -9.979873e-07 -9.979873e-07  1.682308e-06 -6.879951e-07
 [7,]  6.222324e-07  6.222324e-07  6.222324e-07  5.195236e-07  3.422647e-07
 [8,]  5.603366e-07           NaN           NaN  8.649198e-08 -4.285310e-08
 [9,] -9.653143e-07           NaN -9.653143e-07  1.097295e-06  2.956499e-07
[10,]  8.286660e-07           NaN           NaN  1.037164e-06 -3.194901e-07
              [,11]         [,12]         [,13]         [,14]         [,15]
 [1,]  6.348028e-07           NaN  6.348028e-07 -6.779421e-07  2.695101e-07
 [2,]  7.486583e-07           NaN  7.486583e-07 -1.756454e-07 -2.266762e-07
 [3,]  6.754708e-07  6.754708e-07  6.754708e-07 -6.940083e-07  6.066135e-07
 [4,]  4.508225e-07  4.508225e-07  4.508225e-07 -3.288934e-07  3.951099e-07
 [5,]  3.381458e-07  3.381458e-07           NaN -2.122909e-07  2.774253e-07
 [6,]  1.001559e-06  1.001559e-06  1.001559e-06 -1.686604e-06  6.934174e-07
 [7,] -6.152245e-07 -6.152245e-07 -6.152245e-07 -5.155832e-07 -3.419491e-07
 [8,] -5.986317e-07           NaN           NaN -9.434051e-08  4.124269e-08
 [9,]  1.026049e-06           NaN  1.026049e-06 -1.165397e-06 -3.119861e-07
[10,] -8.031951e-07           NaN           NaN -1.005913e-06  3.086086e-07
              [,16]        [,17]         [,18]
 [1,] -1.550204e-06 3.543080e-07 -1.876259e-07
 [2,] -6.316574e-08 4.713515e-08 -2.680633e-07
 [3,] -8.639525e-07 4.254080e-07 -2.990464e-07
 [4,] -6.303767e-07 8.236957e-07  1.056335e-07
 [5,]  4.715963e-07 7.295127e-07 -5.933169e-07
 [6,] -1.107235e-06 1.105627e-06 -1.567929e-06
 [7,] -1.432382e-06 3.538860e-07 -2.906671e-07
 [8,] -7.208188e-07 2.901627e-07 -1.606054e-07
 [9,] -2.389577e-06 9.292818e-07 -1.400272e-06
[10,]  3.668841e-07 6.856613e-07 -9.048976e-07
> range( attr( logLikValGrad, "gradient" ) / logLikValGrad2 - 1, na.rm = TRUE )
[1] -2.389577e-06  1.682308e-06
> attr( logLikValGrad, "gradient" ) - logLikValGrad2
               [,1]          [,2]          [,3]          [,4]          [,5]
 [1,] -4.618528e-08  0.000000e+00 -4.618528e-08 -5.262457e-08 -8.437695e-09
 [2,] -3.042011e-07  0.000000e+00 -3.042011e-07 -1.521006e-08 -2.675637e-08
 [3,] -1.610934e-07 -1.610934e-07 -1.610934e-07 -1.694200e-07 -1.291189e-07
 [4,] -4.458656e-07 -4.458656e-07 -4.458656e-07 -2.366995e-07 -3.437250e-07
 [5,] -3.854694e-07 -3.854694e-07  0.000000e+00 -1.505462e-07 -2.602363e-07
 [6,] -6.321332e-08 -6.321332e-08 -6.321332e-08 -1.790929e-07 -2.992051e-08
 [7,] -7.377432e-08 -7.377432e-08 -7.377432e-08 -5.201395e-08 -2.264855e-08
 [8,] -1.705303e-07  0.000000e+00  0.000000e+00 -3.996803e-09 -8.881784e-10
 [9,] -1.062900e-07  0.000000e+00 -1.062900e-07 -1.376399e-07 -1.011691e-08
[10,] -7.771561e-09  0.000000e+00  0.000000e+00 -1.174061e-08 -1.026956e-09
               [,6]          [,7]          [,8]          [,9]         [,10]
 [1,] -2.412515e-07  0.000000e+00 -2.412515e-07 -2.748912e-07 -4.374279e-08
 [2,] -2.428058e-07  0.000000e+00 -2.428058e-07 -1.199041e-08 -2.131628e-08
 [3,] -2.184919e-07 -2.184919e-07 -2.184919e-07 -2.300382e-07 -1.749711e-07
 [4,] -2.122746e-07 -2.122746e-07 -2.122746e-07 -1.132427e-07 -1.647571e-07
 [5,] -3.455014e-07 -3.455014e-07  0.000000e+00 -1.350031e-07 -2.331468e-07
 [6,] -6.454559e-08 -6.454559e-08 -6.454559e-08 -1.835199e-07 -3.064216e-08
 [7,] -1.989520e-07 -1.989520e-07 -1.989520e-07 -1.391665e-07 -6.061818e-08
 [8,] -2.344791e-07  0.000000e+00  0.000000e+00 -5.551115e-09 -1.110223e-09
 [9,] -7.256695e-08  0.000000e+00 -7.256695e-08 -9.388323e-08 -6.800116e-09
[10,] -1.127709e-07  0.000000e+00  0.000000e+00 -1.769696e-07 -1.654232e-08
              [,11]         [,12]         [,13]         [,14]         [,15]
 [1,] -1.992850e-07  0.000000e+00 -1.992850e-07 -2.272627e-07 -3.608225e-08
 [2,] -1.801892e-07  0.000000e+00 -1.801892e-07 -9.214851e-09 -1.609823e-08
 [3,] -1.947331e-07 -1.947331e-07 -1.947331e-07 -2.052802e-07 -1.565414e-07
 [4,] -3.566036e-07 -3.566036e-07 -3.566036e-07 -1.896261e-07 -2.744471e-07
 [5,] -4.209966e-07 -4.209966e-07  0.000000e+00 -1.652012e-07 -2.837730e-07
 [6,] -7.049916e-08 -7.049916e-08 -7.049916e-08 -2.002426e-07 -3.361200e-08
 [7,] -2.114975e-07 -2.114975e-07 -2.114975e-07 -1.484923e-07 -6.511458e-08
 [8,] -2.342571e-07  0.000000e+00  0.000000e+00 -5.662137e-09 -9.992007e-10
 [9,] -6.832035e-08  0.000000e+00 -6.832035e-08 -8.831824e-08 -6.356027e-09
[10,] -1.226519e-07  0.000000e+00  0.000000e+00 -1.925959e-07 -1.793010e-08
              [,16]         [,17]         [,18]
 [1,]  1.387779e-08  1.121325e-08  3.030909e-08
 [2,]  1.332268e-08  1.143530e-08  3.552714e-08
 [3,]  4.229950e-08  5.040413e-08  3.863576e-08
 [4,] -3.739231e-07 -7.802647e-07 -3.375078e-08
 [5,] -3.281819e-07 -6.576961e-07 -6.030731e-07
 [6,]  2.303713e-09  1.670886e-08  1.026956e-08
 [7,]  1.743050e-08  1.953993e-08  3.752554e-08
 [8,]  4.474199e-08  4.629630e-08  3.086420e-08
 [9,]  9.298118e-09  2.282896e-08  1.078304e-08
[10,] -1.110223e-10  2.164935e-09  2.411960e-08
> range( attr( logLikValGrad, "gradient" ) - logLikValGrad2 )
[1] -7.802647e-07  5.040413e-08
> 
> # for testing state of random number generator
> rnorm( 4 )
[1] -1.3162070  0.7625245  0.9035873  1.6774175
> 
> # calculating marginal effects, unconditional
> margEffUnc <- mvProbitMargEff( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
+    sigma = sigma, data = as.data.frame( xMat ) )
> print( margEffUnc )
     d_y1_d_x1  d_y2_d_x1   d_y3_d_x1   d_y1_d_x2  d_y2_d_x2   d_y3_d_x2
1  0.180673491 0.21966598 -0.12235589 -0.12920309 0.22580951 -0.24120841
2  0.430121958 0.19008353 -0.13195878 -0.37365413 0.21525553 -0.24897191
3  0.115232772 0.36750507 -0.20314566 -0.31483718 0.20898573 -0.24219913
4  0.207611034 0.38276287 -0.22888859 -0.37427350 0.23255246 -0.26855955
5  0.448006648 0.31256137 -0.20905150 -0.38274109 0.23373092 -0.27065767
6  0.026991730 0.15092034 -0.07583674 -0.15288996 0.06575970 -0.09574988
7  0.256300597 0.15702898 -0.13302286 -0.03866694 0.11839993 -0.14725130
8  0.131828020 0.37694792 -0.22611070 -0.33077755 0.21945964 -0.26592681
9  0.302950354 0.02962659 -0.02666829 -0.23089623 0.07290773 -0.09709985
10 0.002095525 0.24265946 -0.12793733 -0.02934265 0.11782358 -0.15753170
     d_y1_d_x3   d_y2_d_x3  d_y3_d_x3    d_y1_d_x4  d_y2_d_x4  d_y3_d_x4
1  0.070272979 -0.40009837 0.30243692 -0.040155988 -0.5334645 0.32993118
2  0.538657270 -0.36576535 0.32022425 -0.307804155 -0.4876871 0.34933554
3  0.287479936 -0.34790671 0.30462485 -0.164274249 -0.4638756 0.33231802
4  0.430074036 -0.42873970 0.37764850 -0.245756592 -0.5716529 0.41198018
5  0.500659694 -0.47229842 0.43028800 -0.286091254 -0.6297312 0.46940509
6  0.089736371 -0.07546714 0.08239434 -0.051277926 -0.1006229 0.08988474
7  0.125115932 -0.32171038 0.32215058 -0.071494819 -0.4289472 0.35143700
8  0.317022613 -0.37862010 0.36777139 -0.181155779 -0.5048268 0.40120515
9  0.168371792 -0.08563215 0.08389399 -0.096212453 -0.1141762 0.09152071
10 0.009358606 -0.15639629 0.15952285 -0.005347775 -0.2085284 0.17402492
> 
> # for testing state of random number generator
> rnorm( 4 )
[1] -0.5074569 -0.4007881  0.9870865 -1.2228328
> 
> # calculating marginal effects, conditional
> # (assuming that all other dependent variables are one)
> margEffCond <- mvProbitMargEff( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
+    sigma = sigma, data = as.data.frame( xMat ), cond = TRUE )
> print( margEffCond )
      d_y1_d_x1  d_y2_d_x1  d_y3_d_x1    d_y1_d_x2  d_y2_d_x2  d_y3_d_x2
1  0.4118196285 0.11755425 -0.3603571 -0.229336023 0.24592945 -0.1258047
2  0.3072493886 0.16496098 -0.2207962 -0.251218729 0.23603249 -0.1732265
3  0.2668136514 0.22747911 -0.3834613 -0.358314743 0.23024729 -0.1482975
4  0.3739634546 0.27583243 -0.3555778 -0.346905711 0.26380199 -0.1562548
5  0.4391801486 0.27082731 -0.2615752 -0.320544987 0.26315436 -0.1630063
6  0.1333475202 0.05063076 -0.3842384 -0.271514059 0.05963121 -0.1100592
7  0.1186209608 0.14525007 -0.1602907 -0.008844268 0.11286656 -0.1545433
8  0.0479944760 0.35027624 -0.2340024 -0.203212079 0.23964177 -0.1769059
9  0.5485854658 0.01846945 -0.1161634 -0.323192759 0.07403491 -0.1034704
10 0.0002023317 0.23196959 -0.1301103 -0.005713415 0.11099101 -0.1661675
     d_y1_d_x3   d_y2_d_x3 d_y3_d_x3    d_y1_d_x4   d_y2_d_x4 d_y3_d_x4
1  0.176511553 -0.35179286 0.2229842 -0.146837465 -0.32872178 0.6037347
2  0.470625850 -0.39065433 0.2417527 -0.400765605 -0.40480342 0.4969012
3  0.440547549 -0.33694170 0.2350549 -0.380306347 -0.32464544 0.5721855
4  0.520056790 -0.45146105 0.2436830 -0.414434159 -0.44879952 0.5673865
5  0.329853048 -0.50531263 0.2791236 -0.223868797 -0.56755035 0.4883268
6  0.253508476 -0.05245314 0.1581382 -0.278241639 -0.04810410 0.3860385
7  0.036015809 -0.30982533 0.2977379 -0.021747581 -0.39933261 0.3574982
8  0.147285010 -0.38617280 0.2839412 -0.091108736 -0.46686983 0.4072656
9  0.361307538 -0.07085862 0.1415298 -0.392918522 -0.06647694 0.3342594
10 0.001136227 -0.14918719 0.1853440 -0.000620818 -0.19920183 0.1994459
> # now with integrals obtained by the Miwa algorithm, reduced precision
> margEffCond1 <- mvProbitMargEff( ~ x1 + x2 + x3 + x4, coef = c( beta ), 
+    sigma = sigma, data = as.data.frame( xMat ), cond = TRUE,
+    algorithm = Miwa( steps = 32 ) )
> print( margEffCond1 )
      d_y1_d_x1  d_y2_d_x1  d_y3_d_x1    d_y1_d_x2  d_y2_d_x2  d_y3_d_x2
1  0.4118175441 0.11744761 -0.3604293 -0.229377392 0.24595064 -0.1258412
2  0.3072778362 0.16499571 -0.2207798 -0.251230455 0.23600462 -0.1732307
3  0.2668567540 0.22752895 -0.3835033 -0.358189399 0.23045343 -0.1481687
4  0.3740368431 0.27590804 -0.3555998 -0.346792914 0.26395440 -0.1561463
5  0.4391762270 0.27082379 -0.2615569 -0.320425619 0.26329930 -0.1629057
6  0.1333669207 0.05068089 -0.3842359 -0.271497048 0.05975710 -0.1100381
7  0.1186476441 0.14525164 -0.1602639 -0.008826922 0.11286814 -0.1545282
8  0.0479957196 0.35027704 -0.2340019 -0.203276650 0.23960011 -0.1769520
9  0.5485472106 0.01837404 -0.1161731 -0.323172242 0.07410392 -0.1034597
10 0.0002125689 0.23197009 -0.1301010 -0.005696324 0.11099282 -0.1661532
    d_y1_d_x3   d_y2_d_x3 d_y3_d_x3    d_y1_d_x4   d_y2_d_x4 d_y3_d_x4
1  0.17654673 -0.35173836 0.2230884 -0.146853300 -0.32870549 0.6038590
2  0.47050847 -0.39074154 0.2416959 -0.400881819 -0.40494388 0.4968085
3  0.44064334 -0.33692357 0.2351269 -0.380357702 -0.32467070 0.5722886
4  0.52019140 -0.45148369 0.2437674 -0.414487863 -0.44884522 0.5675156
5  0.32993069 -0.50525720 0.2791793 -0.223886951 -0.56754997 0.4882992
6  0.25354621 -0.05240628 0.1581628 -0.278296108 -0.04819657 0.3860753
7  0.03601456 -0.30982678 0.2977379 -0.021751728 -0.39933488 0.3574964
8  0.14729740 -0.38616972 0.2839504 -0.091117191 -0.46687210 0.4072593
9  0.36130356 -0.07095788 0.1415239 -0.392920984 -0.06636947 0.3342959
10 0.00107701 -0.14918942 0.1852891 -0.000689856 -0.19920415 0.1993821
> all.equal( margEffCond, margEffCond1 )
 [1] "Component 1: Mean relative difference: 9.319688e-05" 
 [2] "Component 2: Mean relative difference: 0.0002259434" 
 [3] "Component 3: Mean relative difference: 8.422528e-05" 
 [4] "Component 4: Mean relative difference: 0.0002359585" 
 [5] "Component 5: Mean relative difference: 0.0004315704" 
 [6] "Component 6: Mean relative difference: 0.0003287333" 
 [7] "Component 7: Mean relative difference: 0.0002101605" 
 [8] "Component 8: Mean relative difference: 0.0001300584" 
 [9] "Component 9: Mean relative difference: 0.0002044692" 
[10] "Component 10: Mean relative difference: 0.0001675277"
[11] "Component 11: Mean relative difference: 0.0001336327"
[12] "Component 12: Mean relative difference: 0.0001409385"
> 
> # for testing state of random number generator
> rnorm( 4 )
[1] -0.6467480  0.2788967  0.1209011 -1.2689215
> 
> # calculating marginal effects, conditional
> # (assuming that all other dependent variables are as observed)
> margEffCondObs <- mvProbitMargEff( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ), 
+    cond = TRUE )
> print( margEffCondObs )
     d_y1_d_x1  d_y2_d_x1   d_y3_d_x1   d_y1_d_x2  d_y2_d_x2   d_y3_d_x2
1  0.171996342 0.20541522 -0.12683723 -0.09565856 0.22331558 -0.17476430
2  0.453396093 0.18518138 -0.10369269 -0.37122660 0.26642211 -0.08533400
3  0.097176031 0.34345525 -0.20610297 -0.27712919 0.23015413 -0.12829301
4  0.182385396 0.22260219 -0.35557783 -0.34901909 0.24641930 -0.15625477
5  0.395976600 0.26512294 -0.22405904 -0.32295096 0.25167248 -0.13425075
6  0.024154154 0.14516735 -0.07341978 -0.13290567 0.06973857 -0.06173208
7  0.247513245 0.14525007 -0.14360427 -0.02638256 0.11286656 -0.12522160
8  0.105211089 0.35027624 -0.23759517 -0.28310921 0.23964177 -0.14829929
9  0.305110226 0.02953495 -0.02468951 -0.21064577 0.08273875 -0.05169793
10 0.001391671 0.23196959 -0.11609485 -0.01856668 0.11099101 -0.13781508
     d_y1_d_x3   d_y2_d_x3  d_y3_d_x3    d_y1_d_x4   d_y2_d_x4  d_y3_d_x4
1  0.049373080 -0.38496241 0.24421037 -0.035714957 -0.50420545 0.30196558
2  0.517589266 -0.42553291 0.13198369 -0.342320508 -0.46820299 0.27400615
3  0.240569744 -0.35783882 0.19252916 -0.169610695 -0.43559110 0.30277572
4  0.379022298 -0.37335148 0.24368295 -0.263740488 -0.35581139 0.56738648
5  0.538960957 -0.52391216 0.23199224 -0.395069134 -0.53871278 0.45553038
6  0.077901262 -0.07597528 0.06504185 -0.052734091 -0.09824945 0.08501070
7  0.086147908 -0.30982533 0.25313942 -0.065574382 -0.39933261 0.33260130
8  0.252190242 -0.38617280 0.23690022 -0.184985860 -0.46686983 0.37848422
9  0.152442974 -0.08913371 0.05744710 -0.100419550 -0.11271554 0.08247915
10 0.005969436 -0.14918719 0.14822613 -0.004569507 -0.19920183 0.16554889
> # now with integrals obtained by the Miwa algorithm, reduced precision
> margEffCondObs1 <- mvProbitMargEff( cbind( y1, y2, y3 ) ~ x1 + x2 + x3 + x4, 
+    coef = c( beta ), sigma = sigma, data = as.data.frame( cbind( xMat, yMat ) ),
+    cond = TRUE, algorithm = Miwa( steps = 32 ) )
> print( margEffCondObs1 )
     d_y1_d_x1  d_y2_d_x1   d_y3_d_x1   d_y1_d_x2  d_y2_d_x2   d_y3_d_x2
1  0.171991465 0.20539502 -0.12685115 -0.09564462 0.22333831 -0.17480315
2  0.453396083 0.18521403 -0.10371605 -0.37117815 0.26642177 -0.08535933
3  0.097170705 0.34343671 -0.20609885 -0.27708251 0.23019994 -0.12833812
4  0.182370489 0.22262642 -0.35559976 -0.34891097 0.24647789 -0.15614626
5  0.396062172 0.26491181 -0.22410218 -0.32301776 0.25167518 -0.13429372
6  0.024153542 0.14525555 -0.07342138 -0.13290025 0.06986832 -0.06174283
7  0.247601640 0.14525164 -0.14353076 -0.02631610 0.11286814 -0.12516854
8  0.105068348 0.35027704 -0.23771705 -0.28313433 0.23960011 -0.14830372
9  0.305107739 0.02953581 -0.02469139 -0.21063612 0.08275916 -0.05170784
10 0.001376583 0.23197009 -0.11610897 -0.01850896 0.11099282 -0.13777067
     d_y1_d_x3   d_y2_d_x3  d_y3_d_x3    d_y1_d_x4  d_y2_d_x4  d_y3_d_x4
1  0.049369062 -0.38498413 0.24424901 -0.035714021 -0.5042087 0.30197976
2  0.517509460 -0.42554739 0.13203173 -0.342337487 -0.4682704 0.27407828
3  0.240548424 -0.35790074 0.19257697 -0.169608457 -0.4355710 0.30284445
4  0.378960324 -0.37343664 0.24376737 -0.263744039 -0.3558907 0.56751561
5  0.538996584 -0.52376449 0.23212450 -0.395145033 -0.5387374 0.45544566
6  0.077898816 -0.07584485 0.06505061 -0.052733734 -0.0983536 0.08502351
7  0.086045011 -0.30982678 0.25307025 -0.065460222 -0.3993349 0.33273176
8  0.252171647 -0.38616972 0.23688608 -0.184932693 -0.4668721 0.37861102
9  0.152437895 -0.08917606 0.05745498 -0.100419092 -0.1127594 0.08249152
10 0.005925195 -0.14918942 0.14818743 -0.004533174 -0.1992042 0.16558531
> all.equal( margEffCondObs, margEffCondObs1 )
 [1] "Component 1: Mean relative difference: 0.0001814309" 
 [2] "Component 2: Mean relative difference: 0.0001877033" 
 [3] "Component 3: Mean relative difference: 0.0001982085" 
 [4] "Component 4: Mean relative difference: 0.0002147753" 
 [5] "Component 5: Mean relative difference: 0.0001774133" 
 [6] "Component 6: Mean relative difference: 0.0003184793" 
 [7] "Component 7: Mean relative difference: 0.0001634686" 
 [8] "Component 8: Mean relative difference: 0.0001659606" 
 [9] "Component 9: Mean relative difference: 0.0002713405" 
[10] "Component 10: Mean relative difference: 0.0001883154"
[11] "Component 11: Mean relative difference: 9.769836e-05"
[12] "Component 12: Mean relative difference: 0.0002334694"
> 
> # for testing state of random number generator
> rnorm( 4 )
[1]  0.1870145  0.3303074 -1.2090711  1.9202205
> 
> 
